package grpc

import (
	"context"

	"project/internal/usecase"

	"google.golang.org/grpc"
)

// Mocking the generated code interface for simplicity in this environment
// In reality, this would be generated by protoc-gen-go-grpc

type CreateOrderRequest struct {
	UserID string
	Amount float64
}

type CreateOrderResponse struct {
	OrderID string
	Status  string
}

// ServiceServer is the implementation (normally embeds UnimplementedOrderServiceServer)
type ServiceServer struct {
	useCase *usecase.CreateOrder
}

func NewServiceServer(uc *usecase.CreateOrder) *ServiceServer {
	return &ServiceServer{useCase: uc}
}

func (s *ServiceServer) CreateOrder(ctx context.Context, req *CreateOrderRequest) (*CreateOrderResponse, error) {
	// In a real gRPC handler, we map proto types to domain types
	id, err := s.useCase.Execute(ctx, usecase.CreateOrderParams{
		UserID: req.UserID,
		Amount: req.Amount,
	})

	if err != nil {
		return nil, err
	}

	return &CreateOrderResponse{
		OrderID: id,
		Status:  "created",
	}, nil
}

// Register would normally use the generated RegisterOrderServiceServer
func Register(s *grpc.Server, srv *ServiceServer) {
	// s.RegisterService(...) - skipping actual registration call because generated code is missing
}
